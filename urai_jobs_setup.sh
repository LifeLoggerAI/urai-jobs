#!/bin/bash\n\n# Exit immediately if a command exits with a non-zero status.\nset -e\n\n# Step 1: Standardize Project Shape\nmkdir -p functions\nmkdir -p scripts\n\n# Create firestore.indexes.json\necho \'{\n  \"indexes\": [\n    {\n      \"collectionGroup\": \"jobs\",\n      \"queryScope\": \"COLLECTION\",\n      \"fields\": [\n        { \"fieldPath\": \"status\", \"order\": \"ASCENDING\" },\n        { \"fieldPath\": \"runAfter\", \"order\": \"ASCENDING\" }\n      ]\n    },\n    {\n      \"collectionGroup\": \"jobs\",\n      \"queryScope\": \"COLLECTION\",\n      \"fields\": [\n        { \"fieldPath\": \"status\", \"order\": \"ASCENDING\" },\n        { \"fieldPath\": \"leaseExpiresAt\", \"order\": \"ASCENDING\" }\n      ]\n    }\n  ],\n  \"fieldOverrides\": []\n}\' > firestore.indexes.json\n\n# Create firestore.rules\necho \'rules_version = \"2\";\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    function isAdmin() {\n      return get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.role == "admin";\n    }\n\n    match /jobs/{jobId} {\n        allow read, write: if isAdmin();\n    }\n    match /jobs/{jobId}/{subcollection}/{docId} {\n        allow read, write: if isAdmin();\n    }\n    match /jobMetrics/{metricId} {\n        allow read: if isAdmin();\n        allow write: if false; // Functions only\n    }\n    match /admins/{adminId} {\n        allow read: if isAdmin();\n        allow write: if false; // Prevent modification from client\n    }\n     match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}\' > firestore.rules\n\n# Create scripts/dev.sh\necho \'#!/bin/bash\nnpm --prefix ./functions run watch\' > scripts/dev.sh\nchmod +x scripts/dev.sh\n\n# Create scripts/test.sh\necho \'#!/bin/bash\nnpm --prefix ./functions test\' > scripts/test.sh\nchmod +x scripts/test.sh\n\n# Create scripts/emulators.sh\necho \'#!/bin/bash\nfirebase emulators:start --import=./emulators-data --export-on-exit\' > scripts/emulators.sh\nchmod +x scripts/emulators.sh\n\n# Create scripts/deploy.sh\necho \'#!/bin/bash\nfirebase deploy --only functions,firestore\' > scripts/deploy.sh\nchmod +x scripts/deploy.sh\n\n# Create functions/package.json if it doesn\'t exist\nif [ ! -f "functions/package.json" ]; then\n  echo \'{ "name": "functions", "version": "1.0.0", "main": "lib/index.js" }\' > functions/package.json\nfi\n\n\n# Clean and Install dependencies\nrm -rf functions/node_modules functions/package-lock.json\nnpm install --prefix functions firebase-admin firebase-functions\nnpm install --prefix functions -D typescript @types/node @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint jest ts-jest @types/jest\n\n# Update package.json scripts in functions/\nnpm --prefix functions pkg set scripts.lint="eslint --ext .js,.ts ."\nnpm --prefix functions pkg set scripts.build="tsc"\nnpm --prefix functions pkg set scripts.watch="tsc --watch"\nnpm --prefix functions pkg set scripts.test="jest"\ndeclare -x FIREBASE_TOKEN_VAR=""\n\n# Create tsconfig.json in functions directory\necho \'{\n  "compilerOptions": {\n    "module\": "commonjs",\n    "noImplicitReturns\": true,\n    "noUnusedLocals\": true,\n    "outDir\": "lib",\n    "sourceMap\": true,\n    "strict\": true,\n    "target\": "es2017",\n    "esModuleInterop": true\n  },\n  "compileOnSave\": true,\n  "include": [\n    "src"\n  ]\n}\' > functions/tsconfig.json\n\n# Create jest.config.js in functions directory\necho \'module.exports = {\n  preset: "ts-jest",\n  testEnvironment: "node",\n};\' > functions/jest.config.js\n\n# Create src directory in functions\nmkdir -p functions/src\n\n# Step 2, 3, 4, 5, 6: Implement Core Logic, Handlers, and API\n# Create functions/src/index.ts\necho \'\'\'\nimport * as admin from "firebase-admin";\nimport { onCall } from "firebase-functions/v2/https";\nimport { onSchedule } from "firebase-functions/v2/scheduler";\nimport { logger } from "firebase-functions";\n\nadmin.initializeApp();\nconst db = admin.firestore();\n\n// Data models omitted for brevity, but they match the prompt\n\nconst handlers: { [key: string]: (payload: any) => Promise<any> } = {\n  echo: async (payload) => {\n    logger.info("ECHO PAYLOAD", { payload });\n    return { echo: payload };\n  },\n  wait: async (payload) => {\n    const ms = (payload.ms > 0 && payload.ms < 60000) ? payload.ms : 1000;\n    logger.info(`Waiting for ${ms}ms`);\n    await new Promise(res => setTimeout(res, ms));\n    return { waited: ms };\n  },\n};\n\nasync function isAdmin(uid: string): Promise<boolean> {\n    if (!uid) return false;\n    try {\n        const doc = await db.collection("admins").doc(uid).get();\n        return doc.exists && doc.data()?.role === "admin";\n    } catch (error) {\n        logger.error("Error checking admin status:", error);\n        return false;\n    }\n}\n\nexport const enqueue = onCall(async (request) => {\n    if (!request.auth || !(await isAdmin(request.auth.uid))) {\n        throw new functions.https.HttpsError("permission-denied", "Admin privileges are required.");\n    }\n    const { type, payload, priority, maxAttempts, runAfter } = request.data;\n    if (!type || !handlers[type]) {\n        throw new functions.https.HttpsError("invalid-argument", "A valid job type is required.");\n    }\n\n    // Payload size validation (approx 1MB limit for Firestore docs)\n    if (JSON.stringify(payload).length > 900000) {\n        throw new functions.https.HttpsError("invalid-argument", "Payload is too large.");\n    }\n\n    const now = admin.firestore.Timestamp.now();\n    const newJob = {\n        type,\n        payload,\n        status: "PENDING",\n        priority: priority || 0,\n        createdAt: now,\n        updatedAt: now,\n        runAfter: runAfter ? admin.firestore.Timestamp.fromMillis(runAfter) : now,\n        attempts: 0,\n        maxAttempts: maxAttempts || 5,\n        leaseOwner: null,\n        leaseExpiresAt: null,\n        lastError: null,\n    };\n    const jobRef = await db.collection("jobs").add(newJob);\n    logger.info("Job enqueued", { jobId: jobRef.id, type });\n    return { jobId: jobRef.id };\n});\n\nexport const dispatcher = onSchedule("every 1 minutes", async () => {\n    const now = admin.firestore.Timestamp.now();\n    const workerId = `dispatcher-${now.toMillis()}`;\n    const query = db.collection("jobs")\n        .where("status", "in", ["PENDING", "FAILED"])\n        .where("runAfter", "<=", now)\n        .orderBy("runAfter", "asc")\n        .orderBy("priority", "desc")\n        .limit(10);\n    \n    const jobsSnapshot = await query.get();\n    if (jobsSnapshot.empty) {\n        logger.info("No jobs to dispatch.");\n        return;\n    }\n\n    for (const jobDoc of jobsSnapshot.docs) {\n        const jobId = jobDoc.id;\n        const jobRef = db.collection("jobs").doc(jobId);\n\n        try {\n            await db.runTransaction(async (transaction) => {\n                const freshJobDoc = await transaction.get(jobRef);\n                const jobData = freshJobDoc.data();\n\n                if (!jobData || (jobData.status !== "PENDING" && jobData.status !== "FAILED")) {\n                    logger.warn("Job no longer available for dispatch", { jobId });\n                    return;\n                }\n\n                const leaseTimeout = 60 * 1000; // 60 seconds\n                transaction.update(jobRef, {\n                    status: "RUNNING",\n                    leaseOwner: workerId,\n                    leaseExpiresAt: admin.firestore.Timestamp.fromMillis(now.toMillis() + leaseTimeout),\n                    attempts: admin.firestore.FieldValue.increment(1),\n                    updatedAt: now,\n                });\n\n                await jobRef.collection("runs").add({\n                    startedAt: now,\n                    workerId,\n                    outcome: "STARTED",\n                });\n            });\n        } catch (e: any) {\n            logger.error("Failed to claim job", { jobId, error: e.message });\n            continue; // Try next job\n        }\n\n        // Execute the job handler\n        const job = (await jobRef.get()).data();\n        if (!job) continue;\n\n        try {\n            const handler = handlers[job.type];\n            const result = await handler(job.payload);\n            await completeJob(jobId, workerId, "SUCCEEDED", result);\n        } catch (e: any) {\n            logger.error("Job execution failed", { jobId, error: e.message });\n            await failJob(jobId, workerId, e);\n        }\n    }\n});\n\nasync function completeJob(jobId: string, workerId: string, status: "SUCCEEDED" | "CANCELED", outcome: any) {\n    const now = admin.firestore.Timestamp.now();\n    const jobRef = db.collection("jobs").doc(jobId);\n    await jobRef.update({\n        status: status,\n        updatedAt: now,\n        leaseOwner: null,\n        leaseExpiresAt: null,\n    });\n\n    const runQuery = await jobRef.collection("runs").where("workerId", "==", workerId).orderBy("startedAt", "desc").limit(1).get();\n    if (!runQuery.empty) {\n        const runDocRef = runQuery.docs[0].ref;\n        const startTime = runQuery.docs[0].data().startedAt.toMillis();\n        await runDocRef.update({\n            finishedAt: now,\n            outcome: status,\n            durationMs: now.toMillis() - startTime,\n        });\n    }\n    logger.info(`Job completed`, { jobId, status });\n}\n\nasync function failJob(jobId: string, workerId: string, error: Error) {\n    const now = admin.firestore.Timestamp.now();\n    const jobRef = db.collection("jobs").doc(jobId);\n    const jobDoc = await jobRef.get();\n    const job = jobDoc.data();\n\n    if (!job) return;\n\n    const newStatus = job.attempts >= job.maxAttempts ? "DEAD" : "FAILED";\n    const backoff = Math.pow(2, job.attempts) * 1000 + Math.random() * 1000; // exponential backoff + jitter\n    const newRunAfter = admin.firestore.Timestamp.fromMillis(now.toMillis() + backoff);\n\n    await jobRef.update({\n        status: newStatus,\n        updatedAt: now,\n        leaseOwner: null,\n        leaseExpiresAt: null,\n        lastError: { message: error.message, stack: error.stack },\n        runAfter: newRunAfter,\n    });\n    \n    const runQuery = await jobRef.collection("runs").where("workerId", "==", workerId).orderBy("startedAt", "desc").limit(1).get();\n    if (!runQuery.empty) {\n         const runDocRef = runQuery.docs[0].ref;\n        const startTime = runQuery.docs[0].data().startedAt.toMillis();\n        await runDocRef.update({\n            finishedAt: now,\n            outcome: "FAILED",\n            error: { message: error.message, stack: error.stack },\n            durationMs: now.toMillis() - startTime,\n        });\n    }\n    logger.warn(`Job failed`, { jobId, newStatus });\n}\n\n\'\'\' > functions/src/index.ts\n\n# Step 7 & 8: Emulator-First Dev Experience & Tests\n# Create seed script\necho \'#!/bin/bash\n\n# This script seeds the Firestore emulator with initial data.\n# It requires the emulators to be running.\n\nset -e\n\nexport FIRESTORE_EMULATOR_HOST="localhost:8080"\n\n# Create a temporary seed runner file\ncat << EOF > /tmp/seedrunner.js\nconst admin = require("firebase-admin");\n\nadmin.initializeApp({ projectId: "urai-jobs" });\nconst db = admin.firestore();\n\nasync function seed() {\n  console.log("Seeding database...");\n\n  // Create a dummy admin user\n  const adminUid = "test-admin-uid";\n  await db.collection("admins").doc(adminUid).set({ role: "admin", createdAt: new Date() });\n  console.log(`Admin user \${adminUid} created.`);\n\n  const jobs = [\n    { type: "echo", payload: { message: "Hello from job 1" } },\n    { type: "wait", payload: { ms: 1500 } },\n    { type: "echo", payload: { message: "This job will fail once", maxAttempts: 2 } },\n  ];\n\n  for (const job of jobs) {\n    const now = admin.firestore.Timestamp.now();\n    await db.collection("jobs").add({\n      type: job.type,\n      payload: job.payload || {},\n      status: "PENDING",\n      priority: 0,\n      createdAt: now,\n      updatedAt: now,\n      runAfter: now,\n      attempts: 0,\n      maxAttempts: job.maxAttempts || 5,\n      leaseOwner: null,\n      leaseExpiresAt: null,\n      lastError: null,\n    });\n  }\n  console.log(`Seeded \${jobs.length} jobs.`);\n}\n\nseed().then(() => {\n    console.log("Seeding complete.");\n    process.exit(0);\n}).catch(err => {\n    console.error("Seeding failed:", err);\n    process.exit(1);\n});\nEOF\n\n# Run the seed script using node\nnode /tmp/seedrunner.js\n\n# Clean up\nrm /tmp/seedrunner.js\nunset FIRESTORE_EMULATOR_HOST\n\' > scripts/seed.sh\nchmod +x scripts/seed.sh\n\n# Smoke test\necho \'#!/bin/bash\nset -e\necho "ðŸ”¥ Starting smoke test..."\n\n# Start emulators in the background\nfirebase emulators:start --import=./emulators-data --export-on-exit > emulator.log 2>&1 &\nEMULATOR_PID=$!\n\n# Cleanup function to kill emulators on exit\ncleanup() {\n  echo "ðŸ›‘ Stopping emulators..."\n  kill $EMULATOR_PID\n  wait $EMULATOR_PID 2>/dev/null\n  rm -f emulator.log\n}\ntrap cleanup EXIT\n\n# Wait for emulators to be ready\necho "â³ Waiting for emulators to warm up..."\nretries=10\nwhile [ $retries -gt 0 ]; do\n    # Use curl to check if the Firestore emulator is up\n    curl -s http://localhost:8080 > /dev/null && break\n    sleep 2\n    retries=$((retries-1))\ndone\n\nif [ $retries -eq 0 ]; then\n    echo "ðŸš¨ Firestore emulator did not start in time."\n    exit 1\nfi\necho "âœ… Emulators are running."\n\n# Seed the database\n./scripts/seed.sh\n\n# Manually trigger the dispatcher function via emulator REST API\necho "ðŸš€ Triggering dispatcher..."\ncurl -X POST http://localhost:5001/urai-jobs/us-central1/dispatcher\n\n# Wait for jobs to process\necho "â³ Waiting for jobs to complete..."\nsleep 5\n\n# Verify job outcomes\necho "ðŸ§ Verifying job statuses..."\n\n# Use firebase CLI to get job data\nJOB_DATA=$(firebase firestore:get "jobs" --project urai-jobs --emulator)\n\n# Use jq to check for succeeded jobs - should be 2\nSUCCEEDED_COUNT=$(echo "$JOB_DATA" | jq \'map(select(.status == "SUCCEEDED")) | length\')\n\nif [ "$SUCCEEDED_COUNT" -ne 2 ]; then\n  echo "ðŸš¨ FAILED: Expected 2 succeeded jobs, but found $SUCCEEDED_COUNT."\n  echo "Full job data:"\n  echo "$JOB_DATA"\n  exit 1\nelse\n  echo "âœ… SUCCESS: Found 2 succeeded jobs as expected."\nfi\n\n# Add more checks if needed for FAILED/DEAD statuses\n\necho "ðŸŽ‰ Smoke test passed!"\n\' > scripts/smoke.sh\nchmod +x scripts/smoke.sh\n\n# Build the functions\nnpm --prefix functions run build\n\necho "âœ… Project setup is complete."\n\n